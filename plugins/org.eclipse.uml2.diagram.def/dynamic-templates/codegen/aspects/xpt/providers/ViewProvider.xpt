/*
 * Copyright (c) 2007 Borland Software Corporation
 * 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Tatiana Fesenko (Borland) - initial API and implementation
 */

«IMPORT "http://www.eclipse.org/gmf/2006/GenModel"»
«IMPORT "http://www.eclipse.org/emf/2002/Ecore"»
«IMPORT "http://www.eclipse.org/emf/2002/GenModel"»
«IMPORT "http://www.eclipse.org/uml2/diagram/gmfgenext/DiagramFigure/1.0"»

«EXTENSION xpt::diagram::Utils»
«EXTENSION xpt::GenModelUtils»

«AROUND getNodeViewClass FOR gmfgen::GenDiagram-»
	«LET getElements(this).select(n| null != n.viewmap.attributes.typeSelect(gmfgenext::SubstitutableByAttributes).first()) AS substitutableChildren-»
		«IF substitutableChildren.isEmpty()-»
			«targetDef.proceed()-»
		«ELSE»
	«EXPAND xpt::Common::generatedMemberComment»
protected Class getNodeViewClass(org.eclipse.core.runtime.IAdaptable semanticAdapter, org.eclipse.gmf.runtime.notation.View containerView, String semanticHint) {
	if (containerView == null) {
		return null;
	}
	org.eclipse.gmf.runtime.emf.type.core.IElementType elementType = getSemanticElementType(semanticAdapter);
	org.eclipse.emf.ecore.EObject domainElement = getSemanticElement(semanticAdapter);
	
	int visualID;
	if (semanticHint == null) {
«REM»
	No semanticHint specified. Can be a result of call from CanonicalEditPolicy.
	In this situation there should be NO elementType, visualID will be determined
	by VisualIDRegistry.getNodeVisualID() for domainElement.
«ENDREM»«-»
		if (elementType != null || domainElement == null) {
			return null;
		}
		visualID = «EXPAND xpt::editor::VisualIDRegistry::getNodeVisualIDMethodCall»(containerView, domainElement);
	} else {
		visualID = «EXPAND xpt::editor::VisualIDRegistry::getVisualIDMethodCall»(semanticHint);
		if (elementType != null) {
«REM»
	semanticHint specified together with elementType. Both parameters should describe exactly the same 
	diagram element. In addition cecking visualID returned by VisualIDRegistry.getNodeVisualID() for
	domainElement (if specified) - there should be same value.
«ENDREM»«-»
			«EXPAND xpt::providers::ViewProvider::defineElementTypeHint-»
			if (!semanticHint.equals(elementTypeHint)) {
				return null;
			}
			if (domainElement != null && visualID != «EXPAND xpt::editor::VisualIDRegistry::getNodeVisualIDMethodCall»(containerView, domainElement)) {
				return null;
			}
		} else {
«REM»
	elementType was not specified. DomainElement shoud present. Result of calling this method with EObjectAdapter
	as a parameter:
	- ViewService.createNode(View container, EObject eObject, String type, PreferencesHint preferencesHint) 
	- generated ViewFactory.decorateView() for parent element). 

	In first case (passed semanticHint corresponds to the domain element-based diagram node) comparing visualID
	returned from the registry with the semanticHint one.
	In the last case (passed semanticHint corresponds to the compartment or label) checking passed domain model 
	element is the same as specified for the parent view (contract for compartment and labels). 
«ENDREM»«-»
	«IF !getElements(this).select(commonBase | null != commonBase.elementType).isEmpty()-»
			if (domainElement == null) {
				return null;
			}
			switch (visualID) {
				«FOREACH substitutableChildren AS nextSubstitutableChild-»
					«EXPAND caseSubstitutableByVisualID(nextSubstitutableChild) FOR nextSubstitutableChild-»
				«ENDFOREACH-»
				«EXPAND xpt::Common::caseVisualID FOREACH getElements(this).select(commonBase | null != commonBase.elementType && !substitutableChildren.contains(commonBase))»
					if (visualID != «EXPAND xpt::editor::VisualIDRegistry::getNodeVisualIDMethodCall FOR getDiagram()»(containerView, domainElement)) {
						return null;
					}
					break;
				«EXPAND xpt::providers::ViewProvider::caseEssentialChildrenVisualID FOREACH getElements(this).select(commonBase | null != commonBase.elementType).typeSelect(gmfgen::GenNode)-»
			default: 
				return null;
			}
	«ELSE-»
			return null;
	«ENDIF-»
		}
	}
	if (!«EXPAND xpt::editor::VisualIDRegistry::canCreateNodeMethodCall»(containerView, visualID)) {
		return null;
	}
	switch (visualID) {
		«EXPAND xpt::providers::ViewProvider::caseContainerVisualID FOREACH getAllChildContainers()-»
		«EXPAND xpt::providers::ViewProvider::caseEntry FOREACH links.labels-»
	}
	return null;
}
		«ENDIF-»
	«ENDLET-»
«ENDAROUND»

«DEFINE caseSubstitutableByVisualID(gmfgen::GenCommonBase nextSubstitutableChild) FOR gmfgen::GenCommonBase-»
«EXPAND xpt::Common::caseVisualID» {
int suggestedID = «EXPAND xpt::editor::VisualIDRegistry::getNodeVisualIDMethodCall FOR getDiagram()»(containerView, domainElement);
if (visualID != suggestedID &&
	«LET ((gmfgenext::SubstitutableByAttributes)nextSubstitutableChild.viewmap.attributes.typeSelect(gmfgenext::SubstitutableByAttributes).first()) AS group-»
		«FOREACH group.getSubstitutableByNodes() AS nextSubstitution-»
		«EXPAND xpt::editor::VisualIDRegistry::visualID FOR nextSubstitution» != suggestedID &&
		«ENDFOREACH-»		
	true) {
			return null;
		}
	break;
	}
	«ENDLET-»
«ENDDEFINE»
